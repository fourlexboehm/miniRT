#include <SDL.h>
#include <stdio.h>

#define PI 3.14
//Screen dimension constants
const int SCREEN_WIDTH = 1000;
const int SCREEN_HEIGHT = 1000;

// bookmark
// https://www.shadertoy.com/view/XllSRN

typedef struct s_vector3
{
	double	x;
	double	y;
	double	z;
} t_vector3;

t_vector3	add_vector3(const t_vector3 v1, const t_vector3 v2)
{
	t_vector3	ret;

	ret.x = v1.x + v2.x;
	ret.y = v1.y + v2.y;
	ret.z = v1.z + v2.z;
	return (ret);
}
t_vector3	scale_vector3(const t_vector3 vec, const double scale)
{
	t_vector3	new_vec;

	new_vec.x = vec.x * scale;
	new_vec.y = vec.y * scale;
	new_vec.z = vec.z * scale;
	return (new_vec);
}

void printf_vector3(char c, t_vector3* v1)
{
	printf("%c = %lfx, %lfy, %lfz\n", c, v1->x, v1->y, v1->z);
}
t_vector3	subtract_vector3(const t_vector3 v1, const t_vector3 v2)
{
	t_vector3	ret;

	ret.x = v1.x - v2.x;
	ret.y = v1.y - v2.y;
	ret.z = v1.z - v2.z;
	// printf_vector3('r', &ret);
	return (ret);
}

typedef	struct s_sp
{
	t_vector3	pos;
	double		diameter;
}	t_sp;

void draw_vector3(SDL_Renderer *renderer, t_vector3* v1)
{
	SDL_RenderDrawLine(renderer, 500, 500, v1->x + 500, v1->y + 500);
}

typedef struct s_ray
{
	t_vector3	O;
	t_vector3	D;
	int			t;
} t_ray;

typedef struct s_cam
{
	t_vector3	O;
	double		Dx;
	double		Dy;
	double		fov;
} t_cam;

double get_distance_vector3(t_vector3* v1, t_vector3* v2)
{
	return(sqrt(pow(v2->x - v1->x, 2)
		+ pow(v2->y - v1->y, 2)
		+ pow(v2->z + v1->z, 2)));
}

double	get_angle_deg_3D(t_vector3* v1, t_vector3* v2)
{
	// return (atan((v1->y - v2->y + 0.000001) / (v1->x - v2->x + 0.000001)) * 180 / PI);
	return (acos(((v1->x * v2->x + v1->y) * (v2->y + v1->z * v2->z)) / (sqrt(pow(v1->x, 2) + pow(v1->y, 2) + pow(v1->y, 2)) * sqrt(pow(v2->x, 2) + pow(v2->y, 2) + pow(v2->z, 2)))));
}

int dot(t_vector3 *v1, t_vector3 *v2)
{
	return ((v1->x * v2->x) + (v1->y * v2->y) + (v1->z * v2->z));
}

int collide_sphere_3D(t_ray* ray, t_sp* s, SDL_Renderer* r)
{
	double t;
	double t1;
	t_vector3 temp;


	temp = subtract_vector3(s->pos, ray->O);
	// printf_vector3('t', &temp);
	t = dot(&temp, &ray->D);

	double x;
	double y;
	t_vector3 p;

	p = scale_vector3(add_vector3(ray->O, ray->D), ray->t);

	temp = subtract_vector3(s->pos, p);
	// printf_vector3('t', &temp);
	y = get_distance_vector3(&ray->O, &temp);
	// printf("y = %lf\n", y);
	if (y < s->diameter)
	{
		x = sqrt((s->diameter * s->diameter) - (y * y));
		t1 = t - x;
		return (55);
	}
	return (0);
}

// SDL_RenderDrawPoint(renderer, sin((j + k) * 2) * i + 500, cos((j - k) * 2) * i + 500); // draw pixel


void render_frame(SDL_Renderer* renderer, t_sp *sp, t_cam *cam)
{
	t_ray ray;
	ray.O.x = cam->O.x;
	ray.O.y = cam->O.y;
	ray.O.z = cam->O.z;
	ray.D.z = 0;
	ray.D.y = cam->Dy - (cam->fov * .5);
	ray.t = 1000;

	for (int y = 0; y < 1000; y++)
	{
		ray.D.x = cam->Dx - (cam->fov * .5);
		for (int x = 0; x < 1000; x++)
		{
			SDL_SetRenderDrawColor(renderer, 0, collide_sphere_3D(&ray, sp, renderer), 0, 0);
			SDL_RenderDrawPoint(renderer, x, y);
			ray.D.x += cam->fov / 1000;
		}
		ray.D.y += cam->fov / 1000;
		printf("\rprogress...%d%%", y / 10 + 1);
	}
	printf("\nrender done\n");
}


int main(int argc, char* args[]) {
	SDL_Event event;
	SDL_Renderer* renderer;
	SDL_Window* window;

	SDL_Init(SDL_INIT_VIDEO);
	SDL_CreateWindowAndRenderer(SCREEN_HEIGHT, SCREEN_WIDTH, 0, &window, &renderer);
	SDL_SetRenderDrawColor(renderer, 0, 0, 0, 0);
	SDL_RenderClear(renderer);
	//for (i = 0; i < SCREEN_WIDTH; ++i)
	//	SDL_RenderDrawPoint(renderer, (sin(i) * (i / 10)) + 500, cos(i) * (i / 10) + 500);


	/*
	v2.x += 500;
	v2.y += -100;
	v2.z += 0;
	printf_vector3(&v1);

	SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255);
	draw_vector3(renderer, &v1);
	SDL_SetRenderDrawColor(renderer, 0, 0, 255, 255);
	draw_vector3(renderer, &v2);

	SDL_SetRenderDrawColor(renderer, 255, 0, 255, 255);
	SDL_RenderDrawLine(renderer, v1.x + 500, v1.y + 500, v2.x + 500 + (v1.x * (-1)), v2.y + 500 + -(v1.y * (-1)));
	subtract_vector3(&v1, &v2);
	SDL_SetRenderDrawColor(renderer, 0, 255, 0, 255);

	draw_vector3(renderer, &v1);
	printf_vector3(&v1);
	*/

	t_cam cam;
	cam.O.x = 0;
	cam.O.y = 0;
	cam.O.z = 0;
	cam.Dx = 0;
	cam.Dy = 0;
	cam.fov = 45;

	t_sp sp;
	sp.pos.x = 0;
	sp.pos.y = 0;
	sp.pos.z = 4;
	sp.diameter = 10000;

	while (1) 
	{
		// SDL_SetRenderDrawColor(renderer, 0, 0, 0, 255);
		// SDL_RenderClear(renderer);

		render_frame(renderer, &sp, &cam);
		// sp.pos.x += 20;

		SDL_RenderPresent(renderer);
		if (SDL_PollEvent(&event) && event.type == SDL_QUIT)
			break;
		SDL_Delay(10);
	}
	SDL_DestroyRenderer(renderer);
	SDL_DestroyWindow(window);
	SDL_Quit();
	return 0;
}
